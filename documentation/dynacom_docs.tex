%\documentclass{article}
%\usepackage[utf8]{inputenc}

\documentclass[12pt]{article}
\usepackage{graphicx} % This lets you include figures
\usepackage{hyperref}
\hypersetup{
	colorlinks=true,
	linkcolor=[rgb]{0.015, 0.59, 0.77},
	citecolor=[rgb]{0.78, 0.03, 0},  
	urlcolor=[rgb]{1, 0.612, 0.03}
}

\usepackage[rightcaption]{sidecap}
\usepackage{subcaption}
\usepackage{wrapfig}

\usepackage{float}
\usepackage{amsmath} % assumes amsmath package installed
\usepackage{amssymb}  % assumes amsmath package installed
\usepackage{bm}
\usepackage{color, colortbl}
\usepackage{imakeidx}

\makeindex


\title{DynaCoM Manual}
\author{Nahuel Villa}
\date{\today}

\begin{document}
\maketitle{}

\tableofcontents

\clearpage
\newpage

\section{The Contact Class}

\subsection{Instantiation}
\hrulefill



\clearpage

\subsection{Modifying Parameters}
\hrulefill



\clearpage

\subsection{Wrench Matrices}
\hrulefill




\clearpage

\section{The DynaCoM Class}

    This class is in charged to compute the centroidal wrench required to perform certain motion of the robot and to distribute such wrench optimally among the active contacts of the robot.

    In c++ it can be included as 
    %
    \begin{equation*}
    \texttt{\#include <dynacom/dyna\_com.hpp>}
    \end{equation*}
    %
    and in python import it as
    %
    \begin{equation*}
    \texttt{\texttt{from dynacom import DynaCoM}}
    \end{equation*}

\subsection{Instantiation}
\hrulefill

    {\bf Functions:}
    %
    \begin{align*}
        &\texttt{DynaCoM::DynaCoM()}\\
        &\texttt{DynaCoM::initialize()}
    \end{align*}

    The instantiation of the \texttt{DynaCoM class} requires a \texttt{struct} called \texttt{DynaCoMSettings} containing the address of the \texttt{URDF} file that describes the model of the robot.

    We can instantiate the \texttt{DynaCoM} using the \texttt{DynaCoMSettings} as a parameter or by default without parameters, it incorporates the settings later with the method \texttt{initialize()}.
    
% \begin{wrapfigure}{r}{0.50\textwidth} %this figure will be at the right
%     \centering
%     \includegraphics[width=0.50\textwidth]{images/Add_users.png}
%     \caption{This is on a managers computer under the users section.}
%     \label{fig1}
% \end{wrapfigure}


%\begin{figure}[h]
%\includegraphics[width=0.5\textwidth]{images/Add_users.png}
%\caption{This is on a managers computer under the users section.}
%\label{fig1}
%\end{figure}

% \vspace{1.0cm}
\clearpage

\subsection{Computation of the Centroidal Wrench}

\hrulefill

{\bf Function:}
%
\begin{equation*}
    \texttt{DynaCoM::computeDynamics()}
\end{equation*}

This computation is based on the Newton and Euler equations:
%
\begin{align}
    \sum_k f_k &= m\ddot{c} - m g - f_e \\
    \sum_k r_k\times f_k &= \dot{L} -\tau_e,
\end{align}
%
where the robot weight $m g$ is obtained from the \texttt{pinnochio::model}, the known or expected external wrench $f_e$, $\tau_e$ (not supporting wrench, in CoM frame) are provided by the user and the variation of the linear $m\ddot{c}$ and angular $\dot{L}$ momentum are obtained from the function 
%
\begin{equation*}
    \texttt{pinocchio::computeCentroidalMomentumTimeVariation}(q, \dot{q}, \ddot{q}),
\end{equation*}
%
based on the inputs \texttt{position} ($q$), \texttt{velocity} ($\dot{q}$) and \texttt{acceleration} ($\ddot{q}$).

The supporting wrench $\sum_k f_k$ and $\sum_k r_k\times f_k$, expressed in the frame of the CoM, can be accessed by the getter methods:

\begin{align}
    \sum_k f_k &=\texttt{getGroundCoMForce()}; \\
    \sum_k r_k\times f_k &= \texttt{getGroundCoMTorque()};
\end{align}

\subsubsection{Computing the Center of Pressure}

We compute the Center of Pressure (CoP) assuming that the ground is flat and horizontal (\texttt{flatHorizontalGround $=$ true}) or without assumptions (\texttt{flatHorizontalGround $=$ false}). In all cases, the CoP is always computed on a plane $^{x,y}$ perpendicular to the gravity.

\begin{itemize}
    \item[]\hspace*{-10mm}{\bf case \texttt{flatHorizontalGround $=$ {\bf \color{blue}true}}:} In this case the CoP $p$ in $x$ and $y$ coordinates can be computed directly from the centroidal wrench:
    %
    \begin{equation}
        p^{x,y} = c^{x,y} + \dfrac{\left( S (\sum_k r_k\times f_k)^{x, y} - (\sum_k f_k)^{x,y}CoM^{z} \right)}{(\sum_k f_k)^z} 
    \end{equation}
    where $ S=\big[\begin{smallmatrix}\,0\, & \texttt{-}1\\1\, &0
\end{smallmatrix}\big]$ is a $\frac{\pi}{2}$ rotation matrix.

    \item[]\hspace*{-10mm}{\bf case \texttt{flatHorizontalGround $=$ {\bf \color{red}false}}:} Without assumptions, we need to specify where are the robot supports as contact placements, and we must distribute the centroidal wrench among the contacts ({\it learn more about the force distribution in the section \ref{Sec.ForceDist}}).
    %
    \begin{equation}
        p^{x,y} = \dfrac{S\, (\sum_k {\tau^o_k})^{x,y}}{(\sum_k f_k)^z},
    \end{equation}
    %
    where $\tau^o_k$ is the world frame torque produced by the $k$-th contact.
    
\end{itemize}

In a future release, we plan to remove the assumption of Horizontal ground, by replacing the flag \texttt{flatHorizontalGround} by \texttt{flatGround}. Such computation would require additionally a vector normal to the ground plane.

\subsubsection{Computing the non-linearity}

{\bf Function:}
\begin{equation*}
    \texttt{DynaCoM::computeNL()}
\end{equation*}

Once the CoP is computed, we can obtain the ``non-linearity'' $n$, defined as the difference between the CoP and the Virtual Repellent Point VRP $v$ defined as the base of an equivalent Linear Inverted Pendulum (LIP) with the same CoM motion shown by the robot. This requires the time constant of the LIP $ \omega $.
%
\begin{align}
    v^{x,y} &= c^{x,y} - \ddot{c}^{x,y}/\omega^2\\
    n^{x,y} &= p^{x,y} - v^{x,y}.
\end{align}

\clearpage
\newpage

\subsection{Computation of Contact Forces}
\hrulefill

The \texttt{Contact class} is described in the next section. Here we focus on how the \texttt{DynaCoM} deals with the contacts.

\subsubsection{Contact Management}

{\bf Functions:}
\begin{align*}
    &\texttt{DynaCoM::addContact6d()}\\
    &\texttt{DynaCoM::removeContact6d()}\\
    &\texttt{DynaCoM::activateContact6d()}\\
    &\texttt{DynaCoM::deactivateContact6d()}.
\end{align*}

The \texttt{DynaCoM} gathers all the known contacts in a map, called \texttt{known\_contacts}, relating the assigned name of each contact with a \texttt{shared\_ptr} to the contact. Moreover, it has a \texttt{vector<string>} with the names of all active contacts. 

Contacts are incorporated or removed from the \texttt{known\_contacts} with the methods \texttt{DynaCoM::addContact6d()} and \texttt{DynaCoM::removeContact6d()}. When a contact is added to the map of known contacts, the frame where it is defined is associated to one of the model frames according to its name.

Moreover, the known contacts can be activated or deactivated with the methods \texttt{DynaCoM::activateContact6d()} and \texttt{DynaCoM::deactivateContact6d()}.

\subsubsection{Force Distribution} \label{Sec.ForceDist}

{\bf Function:}
\begin{equation*}
    \texttt{DynaCoM::distributeForce()}.
\end{equation*}

One given centroidal wrench can be reproduced by infinite combinations of contact wrenches when we consider several contact surfaces. We manage this redundancy by a numerical optimization based on Quadratic Programming (QP).

In this optimization problem, we make sure that the combined action of all contact forces reproduces our {\bf desired centroidal wrench} \texttt{cWrench}, while maintaining the forces of each contact {\bf unilateral}, within its corresponding {\bf friction cone}. On each contact, we choose the wrench with the {\bf minimum force and torque} components according to user provided weights.

The optimization problem can be written as follows:
%
\begin{align}
    \underset{\bm{\lambda}}{\bm{\mathrm{minimum}}} &\qquad \texttt{Regularization}\\
    \bm{\mathrm{subject\;to}} &\qquad   \texttt{Unilaterality},      \nonumber\\
                  &\qquad  \texttt{FrictionCone},     \nonumber\\
                  & \qquad \texttt{NewtonEuler}, \nonumber
\end{align}
%
where 
%
\begin{align}
    &\texttt{Regularization}& &\hspace{-20mm}\!\!\!=  \qquad\bm{\lambda}^T \,Q \,\bm{\lambda}, \\
    &\texttt{Unilaterality}& &\hspace{-20mm}\texttt{:}\qquad U\,\bm{\lambda} \,<\, 0, \\
    &\texttt{FrictionCone}& &\hspace{-20mm}\texttt{:}\qquad C\,\bm{\lambda} \,<\, 0, \\
    &\texttt{NewtonEuler} & &\hspace{-20mm}\texttt{:}\qquad \mathit{NE} \,\bm{\lambda} \,=\, \texttt{cWrech},
\end{align}
%
the optimization variable $\bm{\lambda}$ is a concatenation of all active contact wrenches expressed locally on each contact frame, and the matrices $Q$, $U$, $C$ and $\mathit{NE}$ are concatenations of all active contact matrices:
%
\begin{align}
    Q & = \begin{bmatrix}
        Q_1 & & \\
         & Q_2 & \\
         & & \ddots
    \end{bmatrix}, & U = \begin{bmatrix}
        U_1 & & \\
         & U_2 & \\
         & & \ddots
    \end{bmatrix}, \\
    C & = \begin{bmatrix}
        C_1 & & \\
         & C_2 & \\
         & & \ddots
    \end{bmatrix}, & \mathit{NE} = \begin{bmatrix}
        \mathit{NE}_1 & \mathit{NE}_2 & \cdots 
    \end{bmatrix}.
\end{align}
%
The numerical subscripts belong to an enumeration of the active contacts.







% \begin{wrapfigure}{r}{0.5\textwidth}
%     \includegraphics[width=0.5\textwidth]{images/email.png}
%     \caption{Note the link expires after 14 days.}
%     \label{fig2}
% \end{wrapfigure}

\end{document}
